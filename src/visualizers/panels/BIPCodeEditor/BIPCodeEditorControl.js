/*globals define, WebGMEGlobal*/
/*jshint browser: true*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Wed Apr 12 2017 11:41:59 GMT-0500 (Central Daylight Time).
 */

define([
    'js/Constants',
    'q',
    'common/util/ejs',
    './../../../templates/ejsCache',
    './../../../parsers/java'
], function (CONSTANTS,
             Q,
             ejs,
             ejsCache,
             javaParser) {

    'use strict';

    var BIPCodeEditorControl;

    BIPCodeEditorControl = function (options) {

        this._logger = options.logger.fork('Control');

        this._client = options.client;

        this._widget = options.widget;
        this._currentNodeId = null;
        this._gatheringSegments = false;
        this._missedEvents = false;

        this._territory = null;
        this._segmentInfo = {};
        this._UID = null;

        this._initialize();

        this._logger.debug('ctor finished');
    };

    BIPCodeEditorControl.prototype._initialize = function () {
        var self = this;

        this._UID = this._client.addUI(self, function (events) {
            self._eventCallback(events);
        });

        this._initWidgetEventHandlers();
    };

    BIPCodeEditorControl.prototype._initWidgetEventHandlers = function () {
        var self = this;
        this._widget.onSave = function (segmentedDocumentObject) {
            // console.log(segmentedDocumentObject);
            self._SaveDocument(segmentedDocumentObject);
        };
    };

    /* * * * * * * * Visualizer content update callbacks * * * * * * * */
    // One major concept here is with managing the territory. The territory
    // defines the parts of the project that the visualizer is interested in
    // (this allows the browser to then only load those relevant parts).
    BIPCodeEditorControl.prototype.selectedObjectChanged = function (nodeId) {

        if (typeof nodeId === 'string' &&
            this._currentNodeId !== nodeId &&
            this._client.getNode(this._client.getNode(nodeId).getMetaTypeId())
                .getAttribute('name') === 'ComponentType') {
            //we have a viable component type so let us change things
            this._currentNodeId = nodeId;
            this._selfPatterns = {};
            this._selfPatterns[nodeId] = {children: 1};
            this._client.updateTerritory(this._UID, this._selfPatterns);
        } else {
            this._logger.info('received unwanted object change event');
        }
    };

    BIPCodeEditorControl.prototype._basicModel2TransitionModel = function (core, transitionNode, path2Name, basicModel) {
        basicModel.src = path2Name[core.getPointerPath(transitionNode, 'src')];
        basicModel.dst = path2Name[core.getPointerPath(transitionNode, 'dst')];
        basicModel.guard = core.getAttribute(transitionNode, 'guardName');
        basicModel.transitionMethod = core.getAttribute(transitionNode, 'transitionMethod');
    };

    BIPCodeEditorControl.prototype._basicModel2GuardModel = function (core, guardNode, basicModel) {
        basicModel.guardMethod = core.getAttribute(guardNode, 'guardMethod');
    };

    BIPCodeEditorControl.prototype._getBasicModel = function (core, node) {
        return {
            name: core.getAttribute(node, 'name'),
            type: core.getAttribute(core.getMetaType(node), 'name'),
            path: core.getPath(node)
        };
    };

    BIPCodeEditorControl.prototype._getComponentTypeModel = function (cTypeId) {
        var self = this,
            deferred = Q.defer(),
            model = {},
            context,
            nameBasedSort = function (nodeA, nodeB) {
                var nameA = context.core.getAttribute(nodeA, 'name'),
                    nameB = context.core.getAttribute(nodeB, 'name');
                if (nameA < nameB) {
                    return -1;
                } else if (nameA > nameB) {
                    return 1;
                }
                return 0;
            };

        Q.ninvoke(self._client, 'getCoreInstance', {})
            .then(function (context_) {
                context = context_;
                return context.core.loadByPath(context.rootNode, cTypeId);
            })
            .then(function (componentType) {
                model.path = cTypeId;
                model.name = context.core.getAttribute(componentType, 'name');
                model.cardinality = context.core.getAttribute(componentType, 'cardinality');
                model.definitions = context.core.getAttribute(componentType, 'definitions');
                model.forwards = context.core.getAttribute(componentType, 'forwards');
                model.constructors = context.core.getAttribute(componentType, 'constructors');
                model.initial = '';
                model.transitions = [];
                model.states = [];
                model.guards = [];

                return context.core.loadChildren(componentType);
            })
            .then(function (children) {
                var i, childModel,
                    path2Name = {};

                children.sort(nameBasedSort);

                for (i = 0; i < children.length; i += 1) {
                    path2Name[context.core.getPath(children[i])] = context.core.getAttribute(children[i], 'name');
                }

                for (i = 0; i < children.length; i += 1) {
                    childModel = self._getBasicModel(context.core, children[i]);
                    //TODO not the nicest way and not too change-resistant
                    switch (childModel.type) {
                        case 'EnforceableTransition':
                        case 'SpontaneousTransition':
                        case 'InternalTransition':
                            self._basicModel2TransitionModel(context.core, children[i], path2Name, childModel);
                            model.transitions.push(childModel);
                            break;
                        case 'Guard':
                            self._basicModel2GuardModel(context.core, children[i], childModel);
                            model.guards.push(childModel);
                            break;
                        case 'InitialState':
                            model.initial = childModel.name;
                        case 'State':
                            model.states.push(childModel);
                            break;
                    }
                }
                deferred.resolve(model);
            })
            .catch(deferred.reject);

        return deferred.promise;
    };

    BIPCodeEditorControl.prototype._buildSegmentInfo = function (nodeId) {
        var self = this,
            deferred = Q.defer(),
            model,
            addSegment = function (segmentId, segmentPath, segmentModel, readonly) {
                var fullSegmentId = segmentId + '*' + segmentPath;

                segmentedDocument.composition.push(fullSegmentId);
                segmentedDocument.segments[fullSegmentId] = {
                    value: ejs.render(ejsCache[segmentId], segmentModel),
                    options: {readonly: readonly === true}
                };
            },
            segmentedDocument = {composition: [], segments: {}, errors: []};

        self._getComponentTypeModel(nodeId)
            .then(function (model_) {
                var i,
                    wholeDocument = ejs.render(ejsCache.complete, model_),
                    parseResult;

                try {
                    parseResult = javaParser.parse(wholeDocument);
                    console.log(parseResult);

                } catch (e) {
                    console.log(e);
                    segmentedDocument.errors.push({line: e.location.start.line, msg: e.message});
                }

                model = model_;
                addSegment('constantImports', model.path, model, true);
                addSegment('userImports', model.path, model);
                addSegment('portsAnnotations', model.path, model, true);
                addSegment('classStart', model.path, model, true);
                addSegment('userDefinitions', model.path, model);
                addSegment('classInitializations', model.path, model, true);
                addSegment('userConstructors', model.path, model);

                for (i = 0; i < model.transitions.length; i += 1) {
                    addSegment('singleTransitionAnnotation', model.transitions[i].path, model.transitions[i], true);
                    addSegment('singleTransition', model.transitions[i].path, model.transitions[i]);
                }

                for (i = 0; i < model.guards.length; i += 1) {
                    addSegment('singleGuardAnnotation', model.guards[i].path, model.guards[i], true);
                    addSegment('singleGuard', model.guards[i].path, model.guards[i]);
                }

                addSegment('classEnd', model.path, model, true);

                deferred.resolve(segmentedDocument);
            })
            .catch(deferred.reject);

        return deferred.promise;
    };

    BIPCodeEditorControl.prototype._SaveDocument = function (changedSegments) {
        var segment,
            segmentId;

        this._client.startTransaction();
        for (segmentId in changedSegments) {
            segment = changedSegments[segmentId];
            segmentId = segmentId.split('*');

            switch (segmentId[0]) {
                case 'userImports':
                    this._client.setAttribute(segmentId[1], 'forwards', segment);
                    break;
                case 'userDefinitions':
                    this._client.setAttribute(segmentId[1], 'definitions', segment);
                    break;
                case 'userConstructors':
                    this._client.setAttribute(segmentId[1], 'constructors', segment);
                    break;
                case 'singleTransition':
                    this._client.setAttribute(segmentId[1], 'transitionMethod', segment);
                    break;
                case 'singleGuard':
                    this._client.setAttribute(segmentId[1], 'guardMethod', segment);
                    break;
            }
        }
        this._client.completeTransaction();
    };

    /* * * * * * * * Node Event Handling * * * * * * * */
    //TODO needs a better change management
    BIPCodeEditorControl.prototype._eventCallback = function (events) {
        var self = this;

        if (events.length > 1) {
            if (self._gatheringSegments) {
                self._missedEvents = true;
            } else {
                self._buildSegmentInfo(this._currentNodeId)
                    .then(function (segmentedDocumentObject) {
                        self._gatheringSegments = false;
                        if (self._missedEvents) {
                            self._missedEvents = false;
                            self._eventCallback([{
                                eid: self._currentNodeId,
                                etype: CONSTANTS.TERRITORY_EVENT_UPDATE
                            }, {}]);
                        } else {
                            self._widget.setSegmentedDocument(segmentedDocumentObject);
                        }
                    })
                    .catch(function (err) {
                        self._gatheringSegments = false;
                        self._logger.error('error during segment info build:', err);
                        if (self._missedEvents) {
                            self._missedEvents = false;
                            self._eventCallback([{
                                eid: self._currentNodeId,
                                etype: CONSTANTS.TERRITORY_EVENT_UPDATE
                            }, {}]);
                        }
                    });
            }
        }
    };

    BIPCodeEditorControl.prototype._onLoad = function (gmeId) {
        var description = this._getObjectDescriptor(gmeId);
        this._widget.addNode(description);
    };

    BIPCodeEditorControl.prototype._onUpdate = function (gmeId) {
        var description = this._getObjectDescriptor(gmeId);
        this._widget.updateNode(description);
    };

    BIPCodeEditorControl.prototype._onUnload = function (gmeId) {
        this._widget.removeNode(gmeId);
    };

    BIPCodeEditorControl.prototype._stateActiveObjectChanged = function (model, activeObjectId) {
        if (this._currentNodeId === activeObjectId) {
            // The same node selected as before - do not trigger
        } else {
            this.selectedObjectChanged(activeObjectId);
        }
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    BIPCodeEditorControl.prototype.destroy = function () {
        this._detachClientEventListeners();
        this._removeToolbarItems();
    };

    BIPCodeEditorControl.prototype._attachClientEventListeners = function () {
        this._detachClientEventListeners();
        WebGMEGlobal.State.on('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged, this);
    };

    BIPCodeEditorControl.prototype._detachClientEventListeners = function () {
        WebGMEGlobal.State.off('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged);
    };

    BIPCodeEditorControl.prototype.onActivate = function () {
        this._attachClientEventListeners();
        this._displayToolbarItems();

        if (typeof this._currentNodeId === 'string') {
            WebGMEGlobal.State.registerActiveObject(this._currentNodeId, {suppressVisualizerFromNode: true});
        }
    };

    BIPCodeEditorControl.prototype.onDeactivate = function () {
        this._detachClientEventListeners();
        this._hideToolbarItems();
    };

    /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
    BIPCodeEditorControl.prototype._displayToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].show();
            }
        } else {
            this._initializeToolbar();
        }
    };

    BIPCodeEditorControl.prototype._hideToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].hide();
            }
        }
    };

    BIPCodeEditorControl.prototype._removeToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].destroy();
            }
        }
    };

    BIPCodeEditorControl.prototype._initializeToolbar = function () {
        var self = this,
            toolBar = WebGMEGlobal.Toolbar;

        this._toolbarItems = [];

        this._toolbarItems.push(toolBar.addSeparator());

        /************** Go to hierarchical parent button ****************/
        this.$btnModelHierarchyUp = toolBar.addButton({
            title: 'Go to parent',
            icon: 'glyphicon glyphicon-circle-arrow-up',
            clickFn: function (/*data*/) {
                WebGMEGlobal.State.registerActiveObject(self._currentNodeParentId);
            }
        });
        this._toolbarItems.push(this.$btnModelHierarchyUp);
        this.$btnModelHierarchyUp.hide();

        /************** Checkbox example *******************/

        this.$cbShowConnection = toolBar.addCheckBox({
            title: 'toggle checkbox',
            icon: 'gme icon-gme_diagonal-arrow',
            checkChangedFn: function (data, checked) {
                self._logger.debug('Checkbox has been clicked!');
            }
        });
        this._toolbarItems.push(this.$cbShowConnection);

        this._toolbarInitialized = true;
    };

    return BIPCodeEditorControl;
});
