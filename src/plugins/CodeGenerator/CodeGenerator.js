/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Mon Jan 23 2017 10:38:24 GMT-0600 (CST).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'common/util/ejs', //for ejs templates
    'common/util/xmljsonconverter', //used to save model as json
    'q'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    ejs,
    Converter,
    Q) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of CodeGenerator.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin CodeGenerator.
     * @constructor
     */
    var CodeGenerator = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    CodeGenerator.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    CodeGenerator.prototype = Object.create(PluginBase.prototype);
    CodeGenerator.prototype.constructor = CodeGenerator;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    CodeGenerator.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            nodeObject;

        nodeObject = self.activeNode;
        
        if (self.core.getPath(nodeObject) === '' ||
            self.core.getAttribute(self.getMetaType(nodeObject), 'name') !== 'BehaviourSpecification') {
            callback(new Error('Active node is not a "BehaviourSpecification".'), self.result);
            return;
        }
        
       
        self.generateBIPModel(nodeObject)
            .then(function (dataModel) {
                self.logger.info(JSON.stringify(dataModel, null, 4)); //There is no way to pass third parameter without passing second parameter in JavaScript. null is a placeholder for replacer function when you need to pass space.
                return self.generateArtifact(dataModel);
            })
            .then(function () {
                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch(function (err) {
                self.logger.error(err);
                self.createMessage(null, err.message, 'error');
                self.result.setSuccess(false);
                callback(null, self.result);
            })
            .done();

         //This will save the changes. If you don't want to save;
        // exclude self.save and call callback directly from this scope.
		//self.loadNodeMap(nodeObject)
          //  .then(function (nodes) {
			//	self.logger.info(Object.keys(nodes));
			//	self.printChildren(nodeObject, nodes);
              //  self.result.setSuccess(true);
                //callback(null, self.result);
            //})
            //.catch(function (err) {
			//	self.logger.error(err.stack);
              //  // Result success is false at invocation.
               // callback(err, self.result);
           // });
    };
    
    
    CodeGenerator.prototype.generateBIPModel = function (node) {
        var self = this,
            deferred = new Q.defer(),
            bipModel = {
                behaviour: {
                    //name: self.core.getAttribute(node, 'name'),
                    componentType: null,
                    initialState: null,
                    states: [
                        //id: <nodePathStr>
                        //name: <string>
                        //events: []
                    ]
                }
            };

      self.core.loadChildren(node, function (err, children) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            var statePromises = [],
                i,
                metaType;

            for (i = 0; i < children.length; i++) {
				
				if (self.isMetaTypeOf(children[i], self.META.ComponentType) === true){
					bipModel.behaviour.name = self.core.
					
				}
				
                if (self.isMetaTypeOf(children[i], self.META.StateBase) === true) {

                    statePromises.push(self.getStateData(children[i]));
                    metaType = self.core.getAttribute(self.getMetaType(children[i]), 'name');

                    if (metaType === 'InitialState') {
                        bipModel.behaviour.initialState = self.core.getPath(children[i]);
                    } else {
                        bipModel.behaviour.states.push(self.core.getPath(children[i]));
                    }
                }
            }

            Q.all(statePromises)
                .then(function (statesData) {
                    bipModel.behaviour.states = statesData;
                    deferred.resolve(bipModel);
                })
                .catch(deferred.reject);
        });

        return deferred.promise;
    };
    
    
    CodeGenerator.prototype.getStateData = function(stateNode) {
        var self = this,
            deferred = new Q.defer(),
            stateData = {
                id: self.core.getPath(stateNode),
                name: self.core.getAttribute(stateNode, 'name'),
                transitions: [
                    // event: <string>
                    // targetId: <nodePathStr>
                ]
            },
            error,
            counter;

        function atDestinationState(connection) {

            return function (err, dstState) {
                if (err) {
                    error = new Error(err);
                } else {
                    stateData.transitions.push({
                        //event: self.core.getAttribute(connection, 'event'),
                        //targetId: self.core.getPath(dstState),
                        targetName: self.core.getAttribute(dstState, 'name'),
                    });
                }

                counter -= 1;
                if (counter === 0) {
                    if (error) {
                        deferred.reject(error);
                    } else {
                        deferred.resolve(stateData);
                    }
                }
            }
        }

        // Load all connections going out from the stateNode, i.e. has the stateNode as 'src'.
        self.core.loadCollection(stateNode, 'src', function (err, connections) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            var i;
            counter = connections.length;

            // For each connection load the destination state.
            for (i = 0; i < connections.length; i += 1) {
                self.core.loadPointer(connections[i], 'dst', atDestinationState(connections[i]));
            }

            // Make sure to resolve when there are no connections.
            if (connections.length === 0) {
                deferred.resolve(stateData);
            }
        });

        return deferred.promise;
    };


	CodeGenerator.prototype.generateArtifact = function (dataModel) {
        var self = this,
            filesToAdd = {},
            deferred = new Q.defer(),
            jsonToXml = new Converter.JsonToXml(),
            artifact = self.blobClient.createArtifact('GeneratedFiles');

        filesToAdd['StateMachine.json'] = JSON.stringify(dataModel, null, 2);
        filesToAdd['metadata.json'] = JSON.stringify({
            projectId: self.projectId,
            commitHash: self.commitHash,
            branchName: self.branchName,
            timeStamp: (new Date()).toISOString(),
            pluginVersion: self.getVersion()
        }, null, 2);
        //self.addXmlStateMachine(filesToAdd, dataModel);

        //self.LANGUAGES.forEach(function (languageInfo) {
        //    self.addLanguageToFiles(filesToAdd, dataModel, languageInfo);
        //});

        artifact.addFiles(filesToAdd, function (err) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            self.blobClient.saveAllArtifacts(function (err, hashes) {
                if (err) {
                    deferred.reject(new Error(err));
                    return;
                }

                self.result.addArtifact(hashes[0]);
                deferred.resolve();
            });
        });

        return deferred.promise;
    };

    
    //========================================
	
  CodeGenerator.prototype.loadNodeMap = function (node) {
   var self = this; 
   return self.core.loadSubTree(node)
       .then(function (nodeArr) {
           var nodes = {},
               i;
           for (i = 0; i < nodeArr.length; i += 1) {
               nodes[self.core.getPath(nodeArr[i])] = nodeArr[i];
           }
           return nodes;
       });
	};
	
	
	CodeGenerator.prototype.print = function (nodes) {
        var self = this,
            path,
            name,
            attr,
            metaNode,
            node;

        for (path in nodes) {
            node = nodes[path];
            name = self.core.getAttribute(node, 'name');
            if (self.isMetaTypeOf(node, self.META.Guard)){
				attr = self.core.getAttribute(node, 'name');
				self.logger.info(name, 'has name', attr);
			}
			if (self.core.getPath(node) === ''){
				self.logger.info("ROOT node does not have a meta-type.");
			}
			else{
				metaNode = self.getMetaType(node);
				self.logger.info(name, 'is of meta-type', self.core.getAttribute(metaNode, 'name'));
			}
		}
    };
    
      CodeGenerator.prototype.printChildren = function (root, nodes, indent) {
        var self = this,
            childrenPaths,
            childNode,
            i;

        indent = indent || '';

        childrenPaths = self.core.getChildrenPaths(root);
        self.logger.info(indent, self.core.getAttribute(root, 'name'), 'has', childrenPaths.length, 'children.');

        for (i = 0; i < childrenPaths.length; i += 1) {
            childNode = nodes[childrenPaths[i]];
            self.printChildren(childNode, nodes, indent + '  ');
        }
    };

    return CodeGenerator;
});
